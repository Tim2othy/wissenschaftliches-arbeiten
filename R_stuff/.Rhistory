mean_failures_yes_absences_no <- mean(failures_yes_absences_no$G3)
mean_failures_no_higher_yes <- mean(failures_no_higher_yes$G3)
mean_failures_no_higher_no <- mean(failures_no_higher_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_absences_yes <- mean((failures_yes_absences_yes$G3 - mean_failures_yes_absences_yes)^2)
mse_failures_yes_absences_no <- mean((failures_yes_absences_no$G3 - mean_failures_yes_absences_no)^2)
mse_failures_no_higher_yes <- mean((failures_no_higher_yes$G3 - mean_failures_no_higher_yes)^2)
mse_failures_no_higher_no <- mean((failures_no_higher_no$G3 - mean_failures_no_higher_no)^2)
# Calculate the total MSE
total_mse <- (mse_failures_yes_absences_yes * nrow(failures_yes_absences_yes) +
mse_failures_yes_absences_no * nrow(failures_yes_absences_no) +
mse_failures_no_higher_yes * nrow(failures_no_higher_yes) +
mse_failures_no_higher_no * nrow(failures_no_higher_no)) / nrow(sd)
total_mse
tree_model_2splits <- rpart(G3 ~ ., data = sd, control = rpart.control(maxdepth = 2))
# Plot the tree
rpart.plot(tree_model_2splits, extra = 101, fallen.leaves = TRUE, type = 2, main = "Decision Tree with Two Splits")
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
failures_no <- subset(sd, failures == 0)
length(failures_no)
length(sd)
hight(failures_no)
summary(failures_no)
# Further split the data
failures_yes_absences_yes <- subset(failures_yes, absences < 1)
failures_yes_absences_no <- subset(failures_yes, absences >= 1)
# Using this as the Data
sd <- student_por
# Removing these because that would just be cheating
sd$G2 <- NULL
sd$G1 <- NULL
# Removing variables that were least important
# during regression and trees
sd$traveltime <- NULL
sd$Medu <- NULL
sd$guardian <- NULL
sd$reason <- NULL
sd$Mjob <- NULL
sd$address <- NULL
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
summary(failures_no) # just a test, all working out
# Further split the data
failures_yes_absences_yes <- subset(failures_yes, absences < 1)
failures_yes_absences_no <- subset(failures_yes, absences >= 1)
failures_no_higher_yes <- subset(failures_no, higher == "no")
failures_no_higher_no <- subset(failures_no, higher == "yes")
# Calculate the mean of G3 for each subset
mean_failures_yes_absences_yes <- mean(failures_yes_absences_yes$G3)
mean_failures_yes_absences_no <- mean(failures_yes_absences_no$G3)
mean_failures_no_higher_yes <- mean(failures_no_higher_yes$G3)
mean_failures_no_higher_no <- mean(failures_no_higher_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_absences_yes <- mean((failures_yes_absences_yes$G3 - mean_failures_yes_absences_yes)^2)
# Calculate the mean of G3 for each subset
mean_failures_yes_absences_yes <- mean(failures_yes_absences_yes$G3)
mean_failures_yes_absences_no <- mean(failures_yes_absences_no$G3)
mean_failures_no_higher_yes <- mean(failures_no_higher_yes$G3)
mean_failures_no_higher_no <- mean(failures_no_higher_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_absences_yes <- mean((failures_yes_absences_yes$G3 - mean_failures_yes_absences_yes)^2)
mse_failures_yes_absences_no <- mean((failures_yes_absences_no$G3 - mean_failures_yes_absences_no)^2)
mse_failures_no_higher_yes <- mean((failures_no_higher_yes$G3 - mean_failures_no_higher_yes)^2)
mse_failures_no_higher_no <- mean((failures_no_higher_no$G3 - mean_failures_no_higher_no)^2)
# Calculate the total MSE
total_mse <- (mse_failures_yes_absences_yes * nrow(failures_yes_absences_yes) +
mse_failures_yes_absences_no * nrow(failures_yes_absences_no) +
mse_failures_no_higher_yes * nrow(failures_no_higher_yes) +
mse_failures_no_higher_no * nrow(failures_no_higher_no)) / nrow(sd)
total_mse
summary(failures_no) # just a test, all working out
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 1)
failures_no_absences_no <- subset(failures_no, absences >= 1)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
## Visualize predictions ----
ggplot(sd, aes(x = G3)) +
geom_point(aes(y = lm_pred, color = "Linear Regression"), alpha = 0.5) +
geom_point(aes(y = tree_pred, color = "Regression Tree"), alpha = 0.5) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
theme_minimal() +
labs(title = "Predicted vs Actual G3 Scores",
x = "Actual G3", y = "Predicted G3",
color = "Model") +
scale_color_manual(values = c("Linear Regression" = "blue", "Regression Tree" = "red"))
tree_model_2splits <- rpart(G3 ~ ., data = sd, control = rpart.control(maxdepth = 2))
# Plot the tree
rpart.plot(tree_model_2splits, extra = 101, fallen.leaves = TRUE, type = 2, main = "Decision Tree with Two Splits")
sd$tree_pred_2splits <- predict(tree_model_2splits)
mse_tree <- mean((sd$G3 - sd$tree_pred_2splits)^2)
print(mse_tree)
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data
failures_yes_absences_yes <- subset(failures_yes, absences < 1)
failures_yes_absences_no <- subset(failures_yes, absences >= 1)
failures_no_higher_yes <- subset(failures_no, higher == "no")
failures_no_higher_no <- subset(failures_no, higher == "yes")
# Calculate the mean of G3 for each subset
mean_failures_yes_absences_yes <- mean(failures_yes_absences_yes$G3)
mean_failures_yes_absences_no <- mean(failures_yes_absences_no$G3)
mean_failures_no_higher_yes <- mean(failures_no_higher_yes$G3)
mean_failures_no_higher_no <- mean(failures_no_higher_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_absences_yes <- mean((failures_yes_absences_yes$G3 - mean_failures_yes_absences_yes)^2)
mse_failures_yes_absences_no <- mean((failures_yes_absences_no$G3 - mean_failures_yes_absences_no)^2)
mse_failures_no_higher_yes <- mean((failures_no_higher_yes$G3 - mean_failures_no_higher_yes)^2)
mse_failures_no_higher_no <- mean((failures_no_higher_no$G3 - mean_failures_no_higher_no)^2)
# Calculate the total MSE
total_mse <- (mse_failures_yes_absences_yes * nrow(failures_yes_absences_yes) +
mse_failures_yes_absences_no * nrow(failures_yes_absences_no) +
mse_failures_no_higher_yes * nrow(failures_no_higher_yes) +
mse_failures_no_higher_no * nrow(failures_no_higher_no)) / nrow(sd)
total_mse
sd$tree_pred <- predict(tree_model_2splits)
mse_tree <- mean((sd$G3 - sd$tree_model_2splits)^2)
tree_model_2splits <- rpart(G3 ~ ., data = sd, control = rpart.control(maxdepth = 2))
# Plot the tree
rpart.plot(tree_model_2splits, extra = 101, fallen.leaves = TRUE, type = 2, main = "Decision Tree with Two Splits")
sd$tree_pred_2splits <- predict(tree_model_2splits)
mse_tree <- mean((sd$G3 - sd$tree_pred_2splits)^2)
print(mse_tree)
sd$tree_pred <- predict(tree_model_2splits)
mse_tree <- mean((sd$G3 - sd$tree_model_2splits)^2)
print(mse_tree)
tree_model_2splits <- rpart(G3 ~ ., data = sd, control = rpart.control(maxdepth = 2))
# Plot the tree
rpart.plot(tree_model_2splits, extra = 101, fallen.leaves = TRUE, type = 2, main = "Decision Tree with Two Splits")
sd$tree_pred_2splits <- predict(tree_model_2splits)
mse_tree <- mean((sd$G3 - sd$tree_pred_2splits)^2)
print(mse_tree)
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data
failures_yes_absences_yes <- subset(failures_yes, absences < 1)
failures_yes_absences_no <- subset(failures_yes, absences >= 1)
failures_no_higher_yes <- subset(failures_no, higher == "no")
failures_no_higher_no <- subset(failures_no, higher == "yes")
# Calculate the mean of G3 for each subset
mean_failures_yes_absences_yes <- mean(failures_yes_absences_yes$G3)
mean_failures_yes_absences_no <- mean(failures_yes_absences_no$G3)
mean_failures_no_higher_yes <- mean(failures_no_higher_yes$G3)
mean_failures_no_higher_no <- mean(failures_no_higher_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_absences_yes <- mean((failures_yes_absences_yes$G3 - mean_failures_yes_absences_yes)^2)
mse_failures_yes_absences_no <- mean((failures_yes_absences_no$G3 - mean_failures_yes_absences_no)^2)
mse_failures_no_higher_yes <- mean((failures_no_higher_yes$G3 - mean_failures_no_higher_yes)^2)
mse_failures_no_higher_no <- mean((failures_no_higher_no$G3 - mean_failures_no_higher_no)^2)
# Calculate the total MSE
total_mse <- (mse_failures_yes_absences_yes * nrow(failures_yes_absences_yes) +
mse_failures_yes_absences_no * nrow(failures_yes_absences_no) +
mse_failures_no_higher_yes * nrow(failures_no_higher_yes) +
mse_failures_no_higher_no * nrow(failures_no_higher_no)) / nrow(sd)
total_mse
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 1)
failures_no_absences_no <- subset(failures_no, absences >= 1)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# Get the variables used for splitting
split_vars <- tree_model_2splits$frame$var[tree_model_2splits$frame$var != "<leaf>"]
split_vars <- unique(as.character(split_vars))
# If there are fewer than 2 splits, notify the user
if(1==1) {
# Create a 3D scatter plot with decision boundaries
plot_ly(sd, x = ~get(split_vars[1]), y = ~get(split_vars[2]), z = ~G3,
type = "scatter3d", mode = "markers",
marker = list(size = 3, color = ~G3, colorscale = "Viridis", opacity = 0.8)) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = split_vars[1]),
yaxis = list(title = split_vars[2]),
zaxis = list(title = "G3")))
# Function to add a plane to the plot
add_plane <- function(p, split_var, split_value, color) {
var_range <- range(sd[[split_var]])
other_var <- setdiff(split_vars, split_var)[1]
other_range <- range(sd[[other_var]])
if(split_var == split_vars[1]) {
x <- rep(split_value, 2)
y <- other_range
} else {
x <- var_range
y <- rep(split_value, 2)
}
z <- matrix(rep(range(sd$G3), each = 2), nrow = 2)
add_surface(p, x = x, y = y, z = z, opacity = 0.3, colorscale = list(c(0, 1), c(color, color)))
}
# Get split points
splits <- tree_model_2splits$splits
split_points <- splits[splits[,"count"] > 0, "index"]
# Create the plot with decision boundaries
p <- plot_ly(sd, x = ~get(split_vars[1]), y = ~get(split_vars[2]), z = ~G3,
type = "scatter3d", mode = "markers",
marker = list(size = 3, color = ~G3, colorscale = "Viridis", opacity = 0.8)) %>%
layout(scene = list(xaxis = list(title = split_vars[1]),
yaxis = list(title = split_vars[2]),
zaxis = list(title = "G3")))
# Add planes for each split
for(i in 1:length(split_points)) {
p <- add_plane(p, split_vars[i], split_points[i], color = c("red", "blue")[i])
}
# Display the plot
p
}
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 1)
failures_no_absences_no <- subset(failures_no, absences >= 1)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# Get the variables used for splitting
split_vars <- tree_model_2splits$frame$var[tree_model_2splits$frame$var != "<leaf>"]
split_vars <- unique(as.character(split_vars))
# Setting up data ----
sd <- student_por
# Removing these because that would just be cheating
sd$G2 <- NULL
sd$G1 <- NULL
# Removing variables that were least important during regression and trees
sd$traveltime <- NULL
sd$Medu <- NULL
sd$guardian <- NULL
sd$reason <- NULL
sd$Mjob <- NULL
sd$address <- NULL
# also do basic test if data is working
View(sd)
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data
failures_yes_absences_yes <- subset(failures_yes, absences < 1)
failures_yes_absences_no <- subset(failures_yes, absences >= 1)
failures_no_higher_yes <- subset(failures_no, higher == "no")
failures_no_higher_no <- subset(failures_no, higher == "yes")
# Calculate the mean of G3 for each subset
mean_failures_yes_absences_yes <- mean(failures_yes_absences_yes$G3)
mean_failures_yes_absences_no <- mean(failures_yes_absences_no$G3)
mean_failures_no_higher_yes <- mean(failures_no_higher_yes$G3)
mean_failures_no_higher_no <- mean(failures_no_higher_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_absences_yes <- mean((failures_yes_absences_yes$G3 - mean_failures_yes_absences_yes)^2)
mse_failures_yes_absences_no <- mean((failures_yes_absences_no$G3 - mean_failures_yes_absences_no)^2)
mse_failures_no_higher_yes <- mean((failures_no_higher_yes$G3 - mean_failures_no_higher_yes)^2)
mse_failures_no_higher_no <- mean((failures_no_higher_no$G3 - mean_failures_no_higher_no)^2)
# Calculate the total MSE
total_mse <- (mse_failures_yes_absences_yes * nrow(failures_yes_absences_yes) +
mse_failures_yes_absences_no * nrow(failures_yes_absences_no) +
mse_failures_no_higher_yes * nrow(failures_no_higher_yes) +
mse_failures_no_higher_no * nrow(failures_no_higher_no)) / nrow(sd)
total_mse
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 1)
failures_no_absences_no <- subset(failures_no, absences >= 1)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
tree_model_2splits <- rpart(G3 ~ ., data = sd, control = rpart.control(maxdepth = 2))
# Plot the tree
rpart.plot(tree_model_2splits, extra = 101, fallen.leaves = TRUE, type = 2, main = "Decision Tree with Two Splits")
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 2)
failures_no_absences_no <- subset(failures_no, absences >= 2)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 3)
failures_no_absences_no <- subset(failures_no, absences >= 3)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# MSE should be 8.309893
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 4)
failures_no_absences_no <- subset(failures_no, absences >= 4)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# Creating the same tree but with swapped splits by hand ----
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 5)
failures_no_absences_no <- subset(failures_no, absences >= 5)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# MSE should be 8.309893
[1] 8.299081
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 7)
failures_no_absences_no <- subset(failures_no, absences >= 7)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# Split the data based on failures
failures_yes <- subset(sd, failures >= 1)
failures_no <- subset(sd, failures == 0)
# Further split the data, swapping the splits
# For failures_yes, split by 'higher' instead of 'absences'
failures_yes_higher_yes <- subset(failures_yes, higher == "yes")
failures_yes_higher_no <- subset(failures_yes, higher == "no")
# For failures_no, split by 'absences' instead of 'higher'
failures_no_absences_yes <- subset(failures_no, absences < 12)
failures_no_absences_no <- subset(failures_no, absences >= 12)
# Calculate the mean of G3 for each subset
mean_failures_yes_higher_yes <- mean(failures_yes_higher_yes$G3)
mean_failures_yes_higher_no <- mean(failures_yes_higher_no$G3)
mean_failures_no_absences_yes <- mean(failures_no_absences_yes$G3)
mean_failures_no_absences_no <- mean(failures_no_absences_no$G3)
# Calculate the MSE for each subset
mse_failures_yes_higher_yes <- mean((failures_yes_higher_yes$G3 - mean_failures_yes_higher_yes)^2)
mse_failures_yes_higher_no <- mean((failures_yes_higher_no$G3 - mean_failures_yes_higher_no)^2)
mse_failures_no_absences_yes <- mean((failures_no_absences_yes$G3 - mean_failures_no_absences_yes)^2)
mse_failures_no_absences_no <- mean((failures_no_absences_no$G3 - mean_failures_no_absences_no)^2)
# Calculate the total MSE
total_mse_swapped <- (mse_failures_yes_higher_yes * nrow(failures_yes_higher_yes) +
mse_failures_yes_higher_no * nrow(failures_yes_higher_no) +
mse_failures_no_absences_yes * nrow(failures_no_absences_yes) +
mse_failures_no_absences_no * nrow(failures_no_absences_no)) / nrow(sd)
total_mse_swapped
# small test
x = c(1,2,3)
